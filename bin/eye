#!/usr/bin/env ruby
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), %w{.. lib}))
require 'eye'
require 'thor'

class Cli < Thor

  desc "status", "show process statuses"
  def status
    res = cmd(:status)
    puts res if res && !res.empty?
    puts
  end 
  
  desc "load CONF", "load config (eye monitoring will start if needs)"
  def load(conf)
    if server_started?
      cmd(:load, conf)
    else
      server_start(conf)
    end
  end
  
  desc "quit", "stop eye monitoring"
  def quit
    cmd(:quit)
    say "monitoring stopped...", :yellow
  end
  
  [:start, :stop, :restart, :remove, :unmonitor].each do |_cmd|
    desc "#{_cmd} [TARGET]", "#{_cmd} app,group or process"
    define_method(_cmd) do |str=""|
      res = cmd(_cmd, str || "")
      if res == :unknown_command
        say "Unknown command", :red
      elsif res == :nothing
        say "No targets, bad pattern!", :red
      else
        say "command #{_cmd} affected to #{res.to_s}"  
      end        
    end
  end

private

  def client
    @client ||= Eye::Client.new(Eye::Settings.socket_path)
  end

  def _cmd(cmd, *args)
    client.command(cmd, *args)
  rescue Errno::ECONNREFUSED, Errno::ENOENT
    :not_started
  end
  
  def cmd(cmd, *args)
    res = _cmd(cmd, *args)

    if res == :not_started
      say "Eye monitoring not found, did you start it?", :red
      exit
    end
    
    res
  end
  
  def server_started?
    _cmd(:ping) == :pong
  end
  
  def server_start(conf = nil)
    Eye::Settings.ensure_eye_dir
    exec_path = File.expand_path(File.join(File.dirname(__FILE__), 'server_eye'))
    pid = Process.spawn(exec_path, conf, " >/dev/null")
    Process.detach(pid)
    File.open(Eye::Settings.pid_path, 'w'){|f| f.write(pid) }
  end

end

Cli.start
